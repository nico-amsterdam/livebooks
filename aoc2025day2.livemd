# Advent of code 2025 day 2

```elixir
Mix.install([
  {:kino, "~> 0.18"}
])
```

## Part 1

https://adventofcode.com/2025/day/2

```elixir
input = Kino.Input.textarea("Please give me input:")

# 11-22,95-115,998-1012,1188511880-1188511890,222220-222224,1698522-1698528,446443-446449,38593856-38593862,565653-565659,824824821-824824827,2121212118-2121212124
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
product_id_ranges =
  Kino.Input.read(input)
  |> String.split(",", trim: true)
  |> Enum.map(fn product_id_range ->
    [from, to] = String.split(product_id_range, "-")
    {String.to_integer(from), String.to_integer(to)}
    end)

length(product_id_ranges)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule Part1 do
  def check_range(from, to) do
    Enum.filter(from..to, fn product_id ->
      split_this = Integer.to_string(product_id)
      full_length = String.length(split_this)

      if full_length > 1 and rem(full_length, 2) == 0 do
        {first_half, second_half} = String.split_at(split_this, div(full_length, 2))
        first_half == second_half
      else
        false
      end
    end)
  end

  def check_ranges(product_id_ranges) do
    Enum.reduce(product_id_ranges, [], fn {from, to}, acc ->
      [check_range(from, to) | acc]
    end)
  end
end

Part1.check_ranges(product_id_ranges) |> List.flatten |> Enum.sum
```

## Part 2

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule Part2 do
  def divisions_to_check(len) when len <= 1, do: []

  def divisions_to_check(len) do
    Enum.filter(1..div(len, 2), fn division -> division > 0 and rem(len, division) == 0 end)
  end

  def all_equal([part | other_list_of_chars]) do
    first_part = :binary.list_to_bin(part)

    Enum.reduce_while(other_list_of_chars, true, fn other_part, _acc ->
      also_equal = :binary.list_to_bin(other_part) == first_part

      if also_equal do
        {:cont, true}
      else
        {:halt, false}
      end
    end)
  end

  def check_range(from, to) do
    Enum.filter(from..to, fn product_id ->
      split_this = Integer.to_charlist(product_id)
      full_length = length(split_this)
      divisions = divisions_to_check(full_length)

      Enum.reduce_while(divisions, false, fn division, _acc ->
        compare_these = Enum.chunk_every(split_this, division)
        found = all_equal(compare_these)

        if found do
          {:halt, true}
        else
          {:cont, false}
        end
      end)
    end)
  end

  def check_ranges(product_id_ranges) do
    Enum.reduce(product_id_ranges, [], fn {from, to}, acc ->
      [check_range(from, to) | acc]
    end)
  end
end

Part2.check_ranges(product_id_ranges) |> List.flatten() |> Enum.sum()
```
